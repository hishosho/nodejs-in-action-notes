> 本项目仅为个人学习《Node.js实战》（第二版）时记录的读书摘要和练习代码。想更好的学习相关知识建议阅读原著，会有很大收获。

# 第二章

## 2.2 开始一个新的Node项目
### 创建模块
exports和module.exports导出。require函数导入。

**require是同步I/O**. 为了助于代码整洁有序和可读性，require是同步I/O。所以尽量不要在I/O密集的地方使用。如正在运行http服务器，若在每个进入的请求上都用了require，会有性能问题。所以require和其他同步操作通常放在程序最初加载的地方。

任何其他对象，函数或变量给exports赋值都是不被允许的。如果要对外提供单个变量，函数或复习，可以用module.exports。如果exports和module.exports同时存在，exports将会被忽略。

## 2.3 用module.exports微调模块的创建
**导出的究竟是什么？**

最终程序中导出的是module.exports。exports只是对module.exports的一个全局引用。最初被定义为可以添加属性的空对象。exports.myFun 只是module.exports.myFun的缩写。

所以，如果把exports设定为别的，就打破module.exports和exports之间的引用关系。可是因为真正导出的是module.exports，那样exports就不能用了（？？这里不明白？？）。如果想保留那个链接，可以用以下方式再次引用：
```
module.exports = exports = Currency;
```
## 2.5 注意事项
1. 如果模块是目录，在模块目录中定义的文件必须被命名为index.js，除非你在这个目录下的一个叫package.json文件里的main里特别指明。
2. Node能把模块作为对象缓存起来。如果程序中的两个文件引用了相同模块，第一个require会把模块返回的数据缓存到内存中，第二个require就不再去访问和计算模块的源文件了。也就是说同一进程中用require加载一个模块得到的是相同对象

## 2.6 使用异步编程技术
Node世界里流两种响应逻辑管理方式： 回调和时间监听
1. 回调： 通常用来定义一次性响应的逻辑。比如数据库查询，指定一个回调函数来处理查询结果。
2. 事件监听器：本质上也是一个回调。不同的是，它跟一个概念实体（事件）相关联。比如当有http请求过来，HTTP服务器会发出一个request事件，你可以监听这个事件，并添加一些响应逻辑。

下面这个例子中，因为用EventEmitter.prototype.on方法在服务器上绑定了一个监听器，所以每当有request事件发出时，服务器就会调用handleRequest函数：
```
server.on('request', handleRequest)
```
一个Node HTTP服务器实例就是一个事件发射器，一个可以继承、能够添加事件发射以及处理能力的类（EventEmitter）。Node的很多核心功能都继承自EventEmitter， 你也能创建自己的事件发射器。

## 2.7 用回调处理一次性事件
见代码demo2.7

## 2.8 用事件发射器处理重复性事件
### 2.8.1 -2.8.2 事件发射器示例
见代码demo2.8
### 2.8.3 创建事件发射器
创建自己的事件发射器，见代码eventEmitter.js和pubAndSub.js
### 2.8.4 扩展事件监听器： 文件监视器
见代码Watcher.js
## 2.9 异步开发的难题
见代码Closure.js
## 2.10 异步逻辑的顺序化
让一组异步任务顺序执行的概念被Node社区成为**流程控制**。这种控制分为**串行**和**并行**。

跟踪串行和并行的流程控制要做编程记账的工作。在实现串行化流程控制时，需要跟踪当前执行的任务，或维护一个尚未执行任务的队列。实现并行化流程控制时需要跟踪有多少个任务要执行完成了。

下面几节会介绍：
- 何时使用串行流程控制
- 实现串行化流程控制
- 如何实现并行化流程控制
- 如何使用第三方模块做流程控制
## 2.11 何时使用串行流程控制
见代码demo2.11
## 2.12 实现串行化流程控制
为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放到一个数组中。这个数组将起到队列的作用：完成一个任务后按顺序从数组中取出下一个。

数组中的每个任务都是一个函数。任务完成后应该调用一个处理器函数，告诉它错误状态和结果。在这一实现中，如果有错误，处理器函数会终止执行；如果没有错误，处理器就从队列中取出下一个任务执行它。

Demo: 开发一个小程序，让它从一个随机选择的RSS预定源中，获取一篇文章的标题和URL，并显示出来。RSS预定源列表放在一个文本文件中。这个程序的输出如下：
```
Of Course ML Has Monads!
http://lambda-the-ultimate,org/node/4306
```
见代码demo2.12

如本例中的实现所示，串行化流程控制本质上是在需要时让回调进场，而不是简单地把他们嵌套起来。

在vue-router里，对路由钩子函数的处理，本质也是对异步任务的串行化流程控制。
## 2.13 实现并行化流程控制
为了让异步任务并行执行，仍然是要把任务放到数组中，但任务的存放顺序无关紧要。每个任务都应该调用处理器函数增加已完成任务的计数值。当所有任务都完成后，处理器函数应该执行后续的逻辑。

我们会做一个简单的程序作为并行化流程控制的例子，它会读取几个文本文件的内容，并输出单词在整个文件中出现的次数。我们会用异步饿readFile函数读取文本文件的内容，所以几个文件的读取可以并行执行。

见代码demo2.13
## 2.14 利用社区里的工具
比如Async，Step和Seq这三个。

下面例子是用Async实现任务序列化的一段脚本，它同时用并行化流程控制下载两个文件，然后把它们压缩归档。

在这个例子中，我们用串行化控制来保证在文件下载完成之前不会做压缩归档处理。

见代码demo2.14

## 2.15 总结
- Node模块是可以被组织称可重用的模块。
- require函数是用来加载模块的。
- module.exports和exports对象是用来分享模块内的函数和变量的。
- package.json文件是用来指明依赖项的，还要指明将哪个文件作为主文件（main）。
- 异步逻辑可以用嵌套回调、事件发射器和流程控制工具来控制。






























